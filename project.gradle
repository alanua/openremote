// Common configuration applied to all projects
import static org.apache.tools.ant.taskdefs.condition.Os.*

// Default repositories for dependency resolution
repositories {
    mavenCentral()
    jcenter()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
    maven {
        url "http://m2repo.openremote.com/content/groups/public/"
    }
    maven {
        url "http://4thline.org/m2"
    }
}

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath "com.moowork.gradle:gradle-node-plugin:1.2.0"
    }
}

// Eclipse needs help
apply plugin: "eclipse"

// Intellij needs help
apply plugin: 'idea'
// Use the same output directories in IDE as in gradle
idea {
    module {
        outputDir file('build/classes/main')
        testOutputDir file('build/classes/test')
    }
}
if(project.convention.findPlugin(JavaPluginConvention)) {
    // Change the output directory for the main and test source sets back to the old path
    sourceSets.main.output.classesDirs = new File(buildDir, "classes/main")
    sourceSets.test.output.classesDirs = new File(buildDir, "classes/test")
}

// Configure versions in gradle.properties (putting a gradle.properties file
// in a subproject only overrides root properties of same name for the actual
// subproject, not for its children!)
version = hasProperty("openremoteVersion") ? openremoteVersion : projectVersion

// Configure Java build
plugins.withType(JavaPlugin).whenPluginAdded {

    // Use Java 8
    tasks.withType(JavaCompile) {
        sourceCompatibility = "1.8"
        def warnLogFile = file("$buildDir/${name}Warnings.log")
        logging.addStandardErrorListener(new StandardOutputListener() {
            void onOutput(CharSequence output) {
                warnLogFile << output
            }
        })
        options.compilerArgs += ["-Xlint:unchecked", "-Xlint:deprecation"]
    }

    // JAR/ZIP base name is the fully qualified subproject name
    archivesBaseName = "${rootProject.name}${path.replaceAll(":", "-")}"
}

// Helper functions for project/task resolution when the main 
// repo is checked out as a git submodule and therefore a subproject
def resolvePath(String path) {
    findProject(":openremote") != null ? ":openremote" + path : path
}

def resolveProject(String path) {
    project(resolvePath(path))
}

def resolveTask(String path) {
    tasks.getByPath(resolvePath(path))
}

ext {
    resolvePath = this.&resolvePath
    resolveProject = this.&resolveProject
    resolveTask = this.&resolveTask
}

/*****************************************************
/* Frontend build and deployment related logic below
******************************************************/

// Inject frontend tasks only for client webapp and consoles this could be its own plugin script and the frontend
// projects could use 'apply from' to make this opt-in
beforeEvaluate {
    if (path.endsWith("client:src:main:webapp") || path.startsWith(":deployment:manager:consoles") || path.startsWith(":openremote:deployment:manager:consoles")) {

        // Add console NodeJS plugin configuration and tasks
        apply plugin: com.moowork.gradle.node.NodePlugin

        // Configure Node JS
        node {
            // Download local nodeJS so not dependent on system install
            download = true
            // Specify the version of node to use (want NPM 5+ for package lock)
            version = '8.9.0'
            // Set the install directory for node
            workDir = file("${rootDir}/.node")
        }

        ext.getNodeDir = {
            def osName = com.moowork.gradle.node.util.PlatformHelper.INSTANCE.getOsName()
            def osArch = com.moowork.gradle.node.util.PlatformHelper.INSTANCE.getOsArch()
            def version = node.version
            def dirName = "node-v${version}-${osName}-${osArch}"
            def nodeDir = node.workDir.absolutePath + File.separator + dirName
            return nodeDir
        }

        ext.getNodeModuleDir = {
            return getNodeDir() + File.separator + "node_modules"
        }

        ext.getNodeModuleGlobal = {
            module -> file("${getNodeModuleDir()}/${module}/bin/${module}")
        }

        ext.getNodeModuleLocal = {
            module -> file("${projectDir}/node_modules/${module}/bin/${module}")
        }

        // Add bower tasks
        task bowerInstall(type: NpmTask) {
            dependsOn nodeSetup
            args = ['install', '-g', 'bower']
            outputs.file(getNodeDir() + File.separator + "bower")
        }
        task bowerUpdate(type: NodeTask) {
            dependsOn bowerInstall
            script = getNodeModuleGlobal('bower')
            args = ['update']
            inputs.file("${project.projectDir}/bower.json")
            outputs.dir("${project.projectDir}/bower_components")
        }
        task bowerPrune(type: NodeTask) {
            dependsOn bowerInstall
            script = getNodeModuleGlobal('bower')
            args = ['prune']
            inputs.file("${project.projectDir}/bower.json")
        }

        // Add polymer tasks
        task polymerInstall(type: NpmTask) {
            dependsOn nodeSetup
            args = ['install', '--global', 'polymer-cli']
            outputs.file(getNodeDir() + File.separator + "polymer")
        }
        task polymerBuild(type: NodeTask) {
            dependsOn polymerInstall
            script = getNodeModuleGlobal('polymer')
            args = ['build']
        }
        task polymerTest(type: NodeTask) {
            dependsOn polymerInstall
            script = getNodeModuleGlobal('polymer')
            args = ['test']
        }
        task polymerServe(type: NodeTask) {
            dependsOn polymerInstall
            script = getNodeModuleGlobal('polymer')
            args = ['serve']
        }

        // Add webpack tasks
        task webpackInstall(type: NpmTask) {
            dependsOn nodeSetup
            args = ['install', '--global', 'webpack']
            outputs.file(getNodeDir() + File.separator + "webpack")
        }
        task webpackDevServerInstall(type: NpmTask) {
            dependsOn webpackInstall
            args = ['install', '--global', 'webpack-dev-server']
            outputs.file(getNodeDir() + File.separator + "webpack-dev-server")
        }
        task webpackBuild(type: NodeTask) {
            dependsOn webpackInstall
            dependsOn npmInstall
            script = getNodeModuleGlobal('webpack')
            execOverrides {
                it.environment['NODE_ENV'] = 'production'
                it.environment['NODE_PATH'] = getNodeModuleDir()
            }
            inputs.file('webpack.config.js')
            inputs.file('package.json')
            inputs.dir('src')
            inputs.dir('node_modules')
            outputs.dir(project.buildDir)
        }
        task webpackServe(type: NodeTask) {
            dependsOn webpackDevServerInstall
            script = getNodeModuleGlobal('webpack-dev-server')
            args = ['--inline', '--hot', '--content-base', 'build/']
        }

        // Add npm script tasks
        task npmServe(type: NpmTask) {
            args = ['run-script', 'serve']
            execOverrides {
                it.environment['NODE_PATH'] = getNodeModuleDir()
            }
        }
        task npmBuild(type: NpmTask) {
            args = ['run-script', 'build']
            execOverrides {
                it.environment['NODE_PATH'] = getNodeModuleDir()
            }
        }
        task npmTest(type: NpmTask) {
            args = ['run-script', 'test']
            execOverrides {
                it.environment['NODE_PATH'] = getNodeModuleDir()
            }
        }
    }
}

// Deployment project configuration
//
// Check if project is the root deployment manager and then injects some tasks to handle copying the manager files
// to the $managerDeploymentDir.
//
// When installDist task executes it copies everything apart from the consoles directory, it then checks each
// console directory and if it isn't a gradle project (i.e. doesn't have a build.gradle) then the directory is
// copied to the $managerDeploymentConsoleDir. If it is a gradle project then it is assumed that it has an installDist
// task and it will handle copying required files to the $managerDeploymentConsoleDir itself.
beforeEvaluate {
    // Disable openremote deployment when set as a submodule
    if (path.startsWith(":openremote:deployment")) {
        tasks.forEach {
            it.enabled = false
        }
    }

    if (path.endsWith(":deployment:manager")) {
        // Add deployment variables so all manager deployment projects can use them
        ext.managerDeploymentDir = "${resolveProject(":manager").buildDir}/install/manager/deployment"
        ext.managerDeploymentConsolesDir = "${resolveProject(":manager").buildDir}/install/manager/deployment/consoles"

        // Copy everything except the consoles
        task copyExcludingConsoles(type: Copy) {
            // Ensure manager installDist has run first as this creates the install directory
            dependsOn resolveTask(":manager:installDist")

            from projectDir
            exclude 'consoles'
            into managerDeploymentDir
        }

        // Create installDist task to copy only 'unmanaged' consoles
        task installDist(type: Copy) {
            ext.isManagedConsole = {consoleDir ->
                return findProject("consoles:${consoleDir.path}") != null
            }

            dependsOn copyExcludingConsoles

            // Copy consoles that don't have a build.gradle (if they have a build.gradle then that console is responsible
            // for copying its output to the console deployment folder and must implement an installDist task)
            from 'consoles'
            into managerDeploymentConsolesDir
            include {
                fileTreeElement ->
                    def consoleDir = fileTreeElement.directory && fileTreeElement.relativePath.parent == RelativePath.EMPTY_ROOT
                    // If it's a console directory check if it is self managed (i.e. has a build.gradle) if it is then don't
                    // include it
                    return !consoleDir || !isManagedConsole(fileTreeElement)
            }
        }
    }
}